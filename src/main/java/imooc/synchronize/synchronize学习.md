
#### 1、Synchronized简介：作用，地位，不控制并发的后果
##### 1.1 作用
能够保证`同一时刻`只有`一个线程`执行该段代码,以达到保证并发安全的效果。
##### 1.2 地位
* Synchronized是Java的关键字，被Java语言原生支持
* 是最基本的互斥同步手段
* 是并发编程中的元老级角色，是并发编程的必学内容
##### 1.3 不适用并发手段会有什么后果？
代码实战：两个线程同时a++, 最后后果会比预计的少
原因：count++，实际上包含了三个操作
* 读取count
* 将count+1
* 将count的值写入内存中

#### 2、两种用法：对象锁和类锁
##### 2.1 对象锁
包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己制定锁对象）
* 代码块形式：手动指定锁对象
* 方法锁形式：synchronized修饰普通方法，锁对象默认为this
##### 2.2 类锁
指Synchronized修饰静态的方法或指定锁为Class对象
* 概念（重要）：Java类可能有很多对象，但只有一个Class对象。所以所谓的类锁，不过就是Class对象的锁而已。
- 用法和效果：类锁只能在同一时刻被同一对象拥有。
* 形式1：synchronized加在static方法上
* 形式2：synchronized（*.class）代码块
#### 3、多线程访问同步方法的7种情况：是否static， Synchronized方法等。
##### 3.1 两个线程同时访问一个对象的同步方法
同步方法只允许一个线程访问
##### 3.2 两个线程访问的是两个对象的同步方法
不受干扰
##### 3.3 两个线程访问的是synchronized的静态方法
只允许一个线程先访问
##### 3.4 同时访问同步方法与非同步方法（有没有被synchronized）修饰
非同步方法不受到影响
##### 3.5 同时访问同一个对象的不同的普通同步方法（非static）
由于访问的是同一个对象，会被锁
##### 3.6 同时访问静态的synchronized和非静态的synchronized方法
加的是不同的两把锁，并不会影响
##### 3.7 方法抛出异常后，会释放锁（与Lock的区别）

#### 7种情况的总结
* 一把锁只能被一个线程获取，没有拿到锁的线程必须等待。
* 每个实例都对应有自己的一把锁，不同的实例之间互不影响。例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象共用同一把锁。
* 无论是方法正常执行完毕或者方法抛出异常，都会释放锁。
* 一个同步方法调用另外一个非同步方法，这个方法并不是线程安全的，因为另一个线程没有被synchronized修饰。

#### 4、Synchronized的性质：可重入，不可中断
##### 4.1 可重入
* 什么是可重入：可重入是指同一线程的外层函数获得锁之后，内存函数可以直接再次获取该锁。
* 好处：避免死锁，提升封装性
* 粒度：线程而非调用（用三种情况来说明和pthread的区别）
```xml
1、证明同一个方法时可重入的
2、证明可重入不要求是同一个方法
3、证明可重入不要求是一个类中的。
```


##### 4.2 不可中断

#### 5、原理：加解锁原理，可重入原理，可见性原理

#### 6、Synchronized的缺陷：效率低，不够灵活，无法预判是否成功获取到锁

#### 7、常见面试问题：使用注意点，如何选择Lock或Synchronized等

#### 8、思考题：如何提高性能，JVM如何决定哪个线程获取锁等

#### 9、总结
